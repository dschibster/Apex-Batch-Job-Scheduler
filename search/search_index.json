{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the SFDX Batch Orchestrator","text":"<p>Fancy meeting you here! I hope you enjoy your stay in this documentation. The SFDX Batch Orchestrator is a tool to make scheduling of Apex Jobs more handy than fiddling around with Anonymous Apex and the \"Scheduled Jobs\" view. With it, you can configure your Jobs with ease, using just the Salesforce UI and some records.</p>"},{"location":"code/","title":"Adjusting your Batch Jobs","text":"<p>SFDX Batch Orchestrator runs based on a generic Scheduler class which in turn is able to invoke our separate Jobs. For this, we need to adjust our Batch Jobs to be compatible with the Base class. </p>"},{"location":"code/#batch-jobs","title":"Batch Jobs","text":"<p>Depending on if you use Enhanced Logging, the implementation of the <code>BatchJobBase</code> class differs slightly. In a standard case, you  need only extend the <code>BatchJobBase</code> class:</p> <p>Important: The Batch Job requires a no-parameter constructor for generic scheduling purposes. You can however have it call another constructor inside with constructor overloading to get your parameters when needed.</p> <pre><code>public class YourBatchJob extends BatchJobBase implements Database.Batchable&lt;SObject&gt;{\n\n  public YourBatchJob(){\n\n  }\n</code></pre> <p>In the end, the last thing you need to do is call <code>super.finishBatch(ctx?.getJobId())</code> with <code>ctx</code> being the name of your Database.BatchableContext variable. This needs to happen in the <code>finish()</code> method of your Batch Job.</p>"},{"location":"code/#queueables","title":"Queueables","text":"<p>If you want to schedule a Queueable for one-off automations that do not need the Batchable interface, the Queueable needs to also extend <code>BatchJobBase</code>, but here the <code>execute()</code> method needs to include the following line first: <code>System.attachFinalizer(this);</code>. This will execute a Finalizer that logs the result of the Queueable after it has finished executing.</p> <pre><code>public class YourQueueable extends BatchJobBase implements Queueable{\n\n    public void execute(QueueableContext QC){\n        System.attachFinalizer(this);\n    }\n}\n</code></pre>"},{"location":"code/#workaround-for-required-parameters","title":"Workaround for required parameters","text":"<p>If you need parameter to be passed into your constructor to properly run your Job, you can make use of constructor overloading to call <code>this()</code> with a set of standard values that you can get via methods of your choosing.</p> <pre><code>public YourBatchJob(){\n  this(fetchStandardInitialValue());\n}\n</code></pre> <pre><code>public class YourBatchJob extends BatchJobBase implements Database.Batchable&lt;SObject&gt;{\n\n  public YourBatchJob(){\n    this(getStartingParameter());\n  }\n\n  public YourBatchJob(String necessaryParameter){\n\n  }\n\n  public static String getStartingParameter(){\n    return 'example';\n  }\n</code></pre> <p>This will make sure to invoke the Batch Job with the necessary parameters.</p>"},{"location":"code/#additionally-when-using-enhanced-logging","title":"Additionally when using Enhanced Logging","text":"<p>In case you use enhanced Logging and you want to listen to the Standard <code>BatchApexErrorEvent</code> when something occurs in the async context, you need to additionally implement <code>Database.RaisesPlatformEvents</code> interface.</p> <pre><code>public class YourBatchJob extends BatchJobBase implements Database.Batchable&lt;SObject&gt;, Database.RaisesPlatformEvents{\n\n  public YourBatchJob(){\n\n  }\n}\n</code></pre>"},{"location":"installation/","title":"Installation","text":"Environment Package Type Install Link Production Unlocked Click here Sandbox Unlocked Click here Production Unmanaged Refer to README in Repository <p>Simply click on one of the Links to install the App (it's recommended to install the Unlocked Package to easily benefit from future updates). After this, assign the \"Batch Job Scheduler\" Permission Set to anyone who needs to access. Administrators automatically get access to the App.</p> <p>This package is standalone as of version 1.3.0 and does not have dependencies on external packages anymore. It can be installed in any org therefore.</p>"},{"location":"logging/","title":"Logging","text":"<p>There are two ways that the Batch Orchestrator produces logs. One of them is the standard (read: legacy) way of creating logs, and one of them uses Platform Events for enhanced logs.</p>"},{"location":"logging/#standard-logging","title":"Standard logging","text":"<p>The only thing that is being logged is the status of the <code>AsyncApexJob</code> record that was created for your Job. It contains the first error it encounters (shortened) and a few other things, but otherwise does not look spectacular. If you want to keep it that way (or feel like you do not want to refactor old jobs), simply keep everything as is.</p> <p>The logs get created in <code>super.finishBatch()</code> when <code>EnhancedLogging__c</code> is set to false for the <code>Batch_Apex_Job__c</code> record. As this is already necessary for the framework to run, there is no additional effort involved.</p>"},{"location":"logging/#enhanced-logging","title":"Enhanced logging","text":"<p>Enhanced Logging leverages Platform Events to create hierarchical logs. This means that under one Parent Log, you will find several different child logs, ideally one for each of the batches that have run (including, optionally, a few information logs).</p> <p>In order to leverage enhanced Logging, here is what you need to do:</p> <ul> <li>Ensure that your Job raises platform events: As seen here</li> <li>Set the Enhanced Logging Flag on the <code>Batch_Apex_Job__c</code> record for your Batch Job to true.</li> <li>Use <code>startLogging()</code> and the different <code>log</code> methods detailed below.</li> </ul> <pre><code>public Database.QueryLocator start(Database.BatchableContext BC) {\n    super.startLogging(BC?.getJobId());\n    return Database.getQueryLocator([SELECT Id, Type FROM Account WHERE Type = '_BJS_Testing_']);\n}\n</code></pre>"},{"location":"logging/#methods-to-start-logging-information-and-batch-results","title":"Methods to start Logging Information and Batch Results","text":""},{"location":"logging/#start-method","title":"Start Method","text":"<p>In order to start logging, your <code>start()</code> method needs to call <code>super.startLogging(BC?.getJobId())</code>. This will create the parent Log and a note that the Batch Job has started. In the end, with enhanced Logging enabled, <code>super.finishBatch()</code> will signalize the Batch Job has ended.</p> <p>If you want to want to add informational logs in the <code>start()</code> method, you can use <code>super.logStartInformation(BC?.getJobId(), String message)</code> to log additional information.</p>"},{"location":"logging/#execute-method","title":"Execute Method","text":"<p>It is required to log the end of each batch when using enhanced logging, as the child logs are what determines that a Job has completed. In order to achieve this, you can use <code>super.logEndOfBatch()</code>, which uses the Batchable Context as well as a few other parameters:</p> <ul> <li><code>List&lt;SObject&gt; scope</code>: The scope of the current batch.</li> <li><code>Id asyncApexJobId</code>: Use <code>BC.getJobId()</code> to fetch the necessary Id here.</li> <li><code>Boolean success</code>: If you catch errors within the Batch Job (for example with partial succeses in <code>Database.update</code>), then this method allows you to include either a failure or a success for the Batch.</li> <li><code>String message</code>: Use this to designate a specific message for the end of a batch.</li> </ul> <p>Should an Exception occur in the <code>execute()</code> method and not be caught, <code>BatchApexErrorEvent</code> will fire and fill in the blanks.</p> <p>Additionally, you can use <code>super.logInformation([List&lt;SObject&gt; scope], BC?.getJobId(), String message)</code> to log additional information inside the EXECUTE context.</p> <pre><code>public void execute(Database.BatchableContext BC, List&lt;Account&gt; scope) {\n    super.logInformation(BC?.getJobId(), 'Test');\n    for (Account account : scope) {\n        account.Type = 'Prospect';\n    }\n    update scope;\n    //log a failed Batch as opposed to the others\n    super.logEndOfBatch(scope, BC?.getJobId(), false, 'Failing for Test');\n}\n</code></pre>"},{"location":"logging/#finish-method","title":"Finish Method","text":"<p>The final 'Batch Job completed' log is created as part of the <code>super.finishBatch()</code> call.</p> <p>If you want to want to add informational logs in the <code>finish()</code> method, you can use <code>super.logFinishInformation(BC?.getJobId(), String message)</code> to log additional information.</p> <pre><code>public void finish(Database.BatchableContext BC) {\n    super.finishBatch(BC?.getJobId());\n}\n</code></pre>"},{"location":"logging/#the-batchjoblogger-class","title":"The BatchJobLogger class","text":"<p>You can use <code>BatchJobLogger</code> to create custom logs to your liking, the only thing <code>BatchJobBase</code> does is encapsulate it so you don't have to worry about setting all components of the <code>log</code> method.</p>"},{"location":"usage/","title":"Using the Orchestrator in the UI","text":""},{"location":"usage/#creating-your-schedule","title":"Creating your Schedule","text":"<p>Inside the \"Batch Orchestrator\" app, first of all you need to create <code>Batch Job Schedule</code> record. You will be asked what kind of schedule you want to use and need to set the necessary fields accordingly. For Hourly Jobs, it will ask you about the starting minute and the amount of hours between jobs, and so on.</p> <p></p> <p>Give it a telling name, as this will be used in following configurations!</p>"},{"location":"usage/#adding-jobs","title":"Adding Jobs","text":"<p>In the <code>Batch Apex Jobs</code> Related List, you are now able to create records for the Batch Jobs you want to run. You are able to either use Queuables or Batchables, as described above. Type in the name of the Batch Job you want to include and put it into a Batch Group. For single-job schedules, you only need to use Batch Group 1. It will become more important once you want to schedule several Batch Jobs one after the other. In that case, make sure to use incremental Batch Groups.</p> <p>If you are using the Enhanced Logging functionality, make sure to check the \"Enhanced Logging\" checkbox</p> <p>Once you have created your Batch Job records, you can immediately run them either by clicking <code>Run Now</code> on the Highlights Panel to execute the entire Schedule, or <code>Run Now</code> on the Job Record in the Related List to execute just the one Batch Job you currently need.</p>"},{"location":"usage/#scheduling-jobs","title":"Scheduling Jobs","text":"<p>Once you have created your Batch Schedule records, you can go into <code>Batch Job Scheduler Configuration</code> to see your Batch Job Schedule records. If you want to schedule your groups with the Cron Expression that you have received as a result of your Batch Job Schedule record, simply check the <code>Scheduled</code> checkbox and click <code>Apply Changes</code> to create the Scheduled Jobs in the background. The Scheduled Jobs will now be connected to the Batch Job Schedule records, so the Batch Jobs inside their grouping will be executed even if you change them after the fact.</p> <p></p>"},{"location":"usage/#changing-the-schedule","title":"Changing the Schedule","text":"<p>If you want to change the schedule for a certain record, you first need to unschedule it using the Batch Job configuration. After that, you are free to change the picklist values and reschedule it using the Configuration again.</p>"}]}